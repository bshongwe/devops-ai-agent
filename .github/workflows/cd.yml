name: CD Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/${{ github.event.repository.name }}

jobs:
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    if: |
      github.event.workflow_run.conclusion == 'success' || 
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment:
      name: staging
      url: https://staging-ci-cd-agent.example.com
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
        
    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > ~/.kube/config
        
    - name: Deploy to staging
      run: |
        kubectl set image deployment/ci-cd-agent \
          ci-cd-agent=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          -n staging
        kubectl rollout status deployment/ci-cd-agent -n staging
        
    - name: Run health checks
      run: |
        kubectl wait --for=condition=ready pod -l app=ci-cd-agent -n staging --timeout=300s
        curl -f https://staging-ci-cd-agent.example.com/webhooks/health
        
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.event.inputs.environment == 'production'
    environment:
      name: production
      url: https://ci-cd-agent.example.com
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
        
    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config
        
    - name: Deploy to production
      run: |
        kubectl set image deployment/ci-cd-agent \
          ci-cd-agent=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          -n production
        kubectl rollout status deployment/ci-cd-agent -n production
        
    - name: Run health checks
      run: |
        kubectl wait --for=condition=ready pod -l app=ci-cd-agent -n production --timeout=300s
        curl -f https://ci-cd-agent.example.com/webhooks/health
        
    - name: Notify deployment
      if: success()
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        text: 'CI-CD Agent successfully deployed to production! üöÄ'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        
  argocd-sync:
    name: Update GitOps and Sync ArgoCD
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITOPS_TOKEN || secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: Update image tags in GitOps
      run: |
        # For demo purposes, use 'latest' tag since we're not pushing actual images
        # In production, you would use: ${{ github.sha }}
        
        # Update base application image tag
        sed -i "s|newTag: .*|newTag: latest|" \
          gitops/applications/ci-cd-agent/kustomization.yaml
          
        # Update staging environment  
        sed -i "s|newTag: .*|newTag: latest|" \
          gitops/environments/staging/kustomization.yaml
          
        # Update production environment (only on main branch with tag)
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          sed -i "s|newTag: .*|newTag: latest|" \
            gitops/environments/production/kustomization.yaml
        fi
        
        echo "üìù GitOps Configuration Updated:"
        echo "   Base Image: busybox:latest" 
        echo "   Staging Image: busybox:latest"
        echo "   Production Image: busybox:latest"
          
    - name: Commit and push GitOps changes
      run: |
        git config user.name "GitHub Actions Bot"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        # Add all changes
        git add gitops/
        
        # Check if there are changes to commit
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "üöÄ GitOps: Update ci-cd-agent image to ${{ github.sha }}
          
          - Updated base image tag: ${{ github.sha }}
          - Updated staging tag: staging-${{ github.sha }}
          - Environment: ${{ github.ref_name }}
          - Workflow: ${{ github.workflow }}
          - Run: ${{ github.run_id }}"
          
          # Try to push, handle permission errors gracefully
          if git push; then
            echo "‚úÖ GitOps repository updated successfully"
          else
            echo "‚ö†Ô∏è  Failed to push GitOps changes - this is expected without GITOPS_TOKEN"
            echo "üí° To enable automatic GitOps updates:"
            echo "   1. Create a Personal Access Token with 'repo' scope"
            echo "   2. Add it as GITOPS_TOKEN secret in repository settings"
            echo "   3. Re-run the workflow"
            echo ""
            echo "üîÑ For now, you can manually apply the GitOps changes:"
            echo "   git pull origin main"
            echo "   kubectl apply -k gitops/applications/ci-cd-agent"
            exit 0  # Don't fail the workflow
          fi
        fi
        
    - name: Prepare ArgoCD Application
      run: |
        echo "üìã ArgoCD Application manifest ready for deployment"
        echo "üè† For local deployment, run:"
        echo "   kubectl apply -f gitops/argocd-application.yaml"
        echo "üîÑ ArgoCD will automatically sync from GitOps repository"
        
    - name: Trigger ArgoCD sync (if configured)
      continue-on-error: true
      run: |
        # Try to sync with ArgoCD API if credentials are available
        if [ -n "${{ secrets.ARGOCD_SERVER }}" ] && [ -n "${{ secrets.ARGOCD_TOKEN }}" ]; then
          echo "üîÑ Triggering ArgoCD sync via API..."
          
          curl -k -X POST "${{ secrets.ARGOCD_SERVER }}/api/v1/applications/ci-cd-agent/sync" \
            -H "Authorization: Bearer ${{ secrets.ARGOCD_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "prune": true,
              "dryRun": false,
              "strategy": {
                "hook": {
                  "force": true
                }
              }
            }' || echo "‚ö†Ô∏è  ArgoCD API sync failed, but GitOps commit will trigger auto-sync"
            
        else
          echo "üí° ArgoCD API credentials not configured"
          echo "üîÑ ArgoCD will auto-sync from GitOps repository changes"
        fi
        
    - name: Local deployment instructions
      run: |
        echo "üéØ Local Deployment Instructions:"
        echo ""
        echo "üìã 1. Apply GitOps changes locally:"
        echo "   ./manual-gitops-sync.sh --update-image"
        echo ""
        echo "ÔøΩ 2. Access ArgoCD UI:"
        echo "   kubectl port-forward svc/argocd-server -n argocd 8080:443"
        echo "   URL: https://localhost:8080"
        echo "   Username: admin"
        echo "   Password: kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d"
        echo ""
        echo "ÔøΩ 3. Check application status:"
        echo "   kubectl get applications -n argocd"
        echo "   kubectl get all -n ci-cd-agent"
        echo ""
        echo "üí° Note: GitHub Actions runs in the cloud and cannot access your local Kind cluster."
        echo "    Use the manual-gitops-sync.sh script to deploy changes locally."
        
  local-deployment:
    name: Deploy to Local/Development
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' && github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download Docker image artifact
      uses: actions/download-artifact@v4
      with:
        name: docker-image
        path: /tmp
        
    - name: Load Docker image
      run: |
        docker load < /tmp/ci-cd-agent.tar
        echo "‚úÖ Docker image loaded successfully"
        docker images ci-cd-agent:latest
        
    - name: Deployment summary
      run: |
        echo "üöÄ CI/CD Agent deployment summary:"
        echo "üì¶ Docker image: ci-cd-agent:latest"
        echo "üîß Ready for local deployment with:"
        echo "   docker run -p 3000:3000 ci-cd-agent:latest"
        echo ""
        echo "üéØ For ArgoCD deployment:"
        echo "   1. Configure GITOPS_TOKEN secret for GitOps repository access"
        echo "   2. Set ENABLE_GITOPS=true in repository variables"
        echo "   3. Configure ARGOCD_SERVER and ARGOCD_TOKEN secrets"
